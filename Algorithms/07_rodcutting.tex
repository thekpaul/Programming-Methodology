\chapter{Rod Cutting Algorithm}
The objective of this challenge is to determine how to cut an imaginary rod to
receive the maximum revenue. Revenue per rod length and initial rod lengths are
given. Note that, if the price for the initial rod length is high enough, the
optimal solution may require no cutting at all.

\section{Brute Force}
\imb[4][10]{\alg/rodcutting.cpp}
\imb[35][39]{\alg/rodcutting.cpp}
\imb[47][47]{\alg/rodcutting.cpp}
\imb[48][49]{\alg/rodcutting.cpp}

Since there are $n-1$ places to either cut or leave, there are $2^{n-1}$ ways in
total to cut a rod of $n$ inches. Therefore a brute force algorithm such as the
one presented solves all possible outcomes and finds the maximum value. Time
Complexity Analysis shows an exponential time function.

\section{Dynamic Programming: Top-Down Approach}
\imb[12][22]{\alg/rodcutting.cpp}
\imb[35][39]{\alg/rodcutting.cpp}
\imb[41][45]{\alg/rodcutting.cpp}
\imb[48][49]{\alg/rodcutting.cpp}

The most critical reason for the brute force algorithm's exponentailly long time
conplexity is that brute force repeats sonving what is essentially the same set
of divisions. For example, when processing the cutting of a $9$ inch rod, brute
force algorithm processes the same 2, 3, and 4-inch dsivision as 6 different
methods $(2,~3,~4),~(3,~2,~4),\cdots$. This can be solved by recording results
of previous iterations of the recursion, or the \textbf{memoisation} of previous
data. With the top-down method presented above, the new array \imc{int* arr} is
a storage array for the previously processed results.

\section{Dynamic Programming: Bottom-Up Approach}
\imb[24][33]{\alg/rodcutting.cpp}
\imb[35][39]{\alg/rodcutting.cpp}
\imb[40][40]{\alg/rodcutting.cpp}
\imb[48][49]{\alg/rodcutting.cpp}

Unusual circumstances can lead to failures in top-down algorithms where not all
possible outcomes are tested. The bottom-up approach above often shows strength
in constant factors and overall stability, and can be mathematically proven in
its ability to always process all subproblems, although such proof will not be
provided in this manual.

Both Top-Down and Bottom-Up approaches show a time complexity of $T(n)=\Theta
\left(n^2\right)$.
